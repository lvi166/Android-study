
https://www.jianshu.com/p/fbe2320e57fa
* ## 1. Java中 == .equals() hashcode() 的区别
> == 对象对比两个对象在内存中的地址

> 默认的 .euqls() 是实现 == 。String类重写了 equals()方法先对比对象 然后再对比内容

> hashcode()方法返回对象的Hash码

* ## 2. int chat long 等等各占多少字节
- int 4个
- char 占 2个字节
- short 占两个字节
- float 4个字节
- long 占 8个字节
- double 8字节

* ## 3. int Integer 的区别
> int 是基本数据类型 Integer是int 的包装类
* ## 4. String StringBuilder StringBuffer 区别
- String 是final修饰的类是不可变的对象每次变化都要新建一个对象。字符串变化比较大不推荐使用。
- StringBuffer是线程安全的但是效率低
- StringBuilder 是线程不安全的但是效率高

* ## 4. Java 垃圾回收算法

- 4.1 如何判断对象是否可以回收

- 引用计数法 应为引用和对象是有关联的，操作对象必须用到引用，所以当对象有一个引用时，计数器+1，反之如果对象的引用为0时，代表这个对象是可以回收的，但是如果有循环引用的情况出现，则该算法就无法回收

 - 根搜索算法（可达性分析法） 可达性分析就是顺着GCRoot根一直搜索 并构成一条引用链，如果对象在引用链上则可达，不在引用链上的则不可达，不可达对象可以作为回收的对象。

- 4.2 垃圾回收算法

  - 标记清除法 对需要回收的对象进行标记，然后统一清除，并清空对象的内存区域，但是容易产生内存碎片，如果堆中有大量的对象是可回收的，收集器需要执行大量的标记收集操作，影响效率
  - 标记-复制算法 把内存区域分为运行区域和预留区域，当运行区域内存不够的时候，复制到预留区域并剔除需要回收的对象。并排序。这样避免了效率和碎片问题。 
  - 标记整理算法， 对对象进行标记后，在整理阶段，第一步先把需要把存活的对象移动到内存空间的一端，并将存活空间外部的空间清空。
- 4.3 新生代 老年代的内存结构，内存区域中新生代站1/3，老年代占2/3。而且新生代又分 eden s0 s1 三个区域 分别是 8/1/1。
新生对象先放入新生代的 eden区，如果eden区域空间不足，触发一次MinorGC，并把存活对象复制到S0区域。
当老年代内存区域不足时候 触发一次 FullGC（标记整理算法）

* ## 5. Java 中的锁
  java中常见的锁的实现有两种 synchronized 关键字和Lock
  - synchronized 是一个非公平的，悲观，独享，互斥，可重入的重量级锁
  - ReentrantLock：默认非公平但可实现公平的，悲观，独享，互斥，可重入，重量级锁
  - ReentrantReadWriteLock: 默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入，重量级锁
   
- synchionized 关键字是JVM提供的，synchironized修饰的代码块或者方法会在对应的字节码文件中生成 monitorenter和 moniterexit 两个字节码命令。获取对象锁时候 monitorenter
  
- ## 5. volatile关键字
- 可见性 写入一个volatile 变量时 强制他写入到内存中，读取一个volatile变量时，强制他读取内存中的数据
- 指令重排
- volatile 不能保证原子性

JVM 要保证“完全可见性”？由于缓存和指令重排等机制，我们对程序执行顺序和执行结果的预期，可能跟真实的执行顺序和结果并不相同。



